基础知识就像是一座大楼的地基，它决定了我们的技术高度。而要想快速做出点事情，前提条件一定是基础能力过硬，“内功”要到位

越是厉害的公司，越是注重考察数据结构与算法这类基础知识。相比短期能力，他们更看中你的长期潜力。

作为业务开发，我们会用到各种框架、中间件和底层系统，比如 Spring、RPC 框架、消息中间件、Redis 等等。在这些基础框架中，一般都揉和了很多基础数据结构和算法的设计思想。

基础架构研发工程师，写出达到开源水平的框架才是你的目标！

高手之间的竞争其实就在细节。这些细节包括：你用的算法是不是够优化，数据存取的效率是不是够高，内存是不是够节省等等。这些累积起来，决定了一个框架是不是优秀。

何为编程能力强？是代码的可读性好、健壮？还是扩展性好？我觉得没法列，也列不全。但是，在我看来，性能好坏起码是其中一个非常重要的评判标准。

数据结构和算法是相辅相成的。数据结构是为算法服务的，算法要作用在特定的数据结构之上。

想要学习数据结构与算法，首先要掌握一个数据结构与算法中最重要的概念——复杂度分析。
数据结构和算法解决的是如何更省、更快地存储和处理数据的问题

学习要学会找重点

20 个最常用的、最基础数据结构与算法，不管是应付面试还是工作需要，只要集中精力逐一攻克这 20 个知识点就足够了。
这里面有 10 个数据结构：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie 树；10 个算法：递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法。

在学习数据结构和算法的过程中，要学习它的“来历”“自身的特点”“适合解决的问题”以及“实际的应用场景”。
学习知识的过程是反复迭代、不断沉淀的过程。

只要讲到数据结构与算法，就一定离不开时间、空间复杂度分析

事后统计法:
1. 测试结果非常依赖测试环境
2. 测试结果受数据规模的影响很大

我们需要一个不用具体的测试数据来测试，就可以粗略地估计算法的执行效率的方法

所有代码的执行时间 T(n) 与每行代码的执行次数n成正比

	T(n) = O(f(n))

f(n) 表示每行代码执行的次数总和
公式中的O，表示代码的执行时间 T(n) 与 f(n) 表达式成正比。

大O时间复杂度实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势，所以，也叫作渐进时间复杂度（asymptotic time complexity），简称时间复杂度。

当 n 很大时，你可以把它想象成10000、100000。而公式中的低阶、常量、系数三部分并不左右增长趋势，所以都可以忽略。

- O(1)

- O(log n), O(nLog n)

		i = 1;
		while ( i <= n) {
			i = i * 2;
		}

log3n 就等于 log32 * log2n，所以 O(log3n) = O(C * log2n)，其中 C=log32 是一个常量。基于我们前面的一个理论：在采用大 O 标记复杂度的时候，可以忽略系数，即 O(Cf(n)) = O(f(n))。

- O(m+n), O(m*n)


时间复杂度的全称是渐进时间复杂度，表示算法的执行时间与数据规模之间的增长关系。
类比一下，空间复杂度全称就是渐进空间复杂度（asymptotic space complexity），表示算法的存储空间与数据规模之间的增长关系。



最好情况时间复杂度（best case time complexity）、
最坏情况时间复杂度（worst case time complexity）、
平均情况时间复杂度（average case time complexity）、
均摊时间复杂度（amortized time complexity）










Redis 中，键的数据类型是字符串,值的数据类型有很多，常用的数据类型有这样几种，它们分别是字符串、列表、字典、集合、有序集合。

